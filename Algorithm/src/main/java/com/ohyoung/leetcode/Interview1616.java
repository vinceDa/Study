package com.ohyoung.leetcode;

import java.util.Arrays;

/**
 *
 *  给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。
 *  注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
 *
 *  示例：
 *
 *  输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
 *  输出： [3,9]
 * @author ohYoung
 * @date 2020/11/6 16:06
 */
public class Interview1616 {

    public static void main(String[] args) {
        int[] array = new int[]{-904,-903,-903,-899,-898,-897,-897,-897,-890,-890,-889,-889,-887,-885,-883,-883,-880,-879,-876,-869,-868,-846,-844,-840,-835,-831,-828,-828,-828,-825,-825,-819,-816,-811,-809,-808,-808,-807,-806,-805,-803,-800,-199,-634,-36,-258,-306,-379,-206,-48,-726,-760,-261,-328,-602,-369,-708,-157,-272,-245,-242,-518,-549,-115,-222,-689,-21,-655,-140,-129,-760,-165,-600,-184,-779,-67,-566,-193,-670,-382,-652,-496,-236,-784,-34,-375,-407,-345,-479,-44,-614,-453,-698,-737,-352,-336,-491,-731,-592,-540,-50,-800,-213,-40,-105,-574,-545,-153,-393,-406,-274,-292,-42,-259,-443,-799,-52,-298,-388,-203,-597,-502,-29,-777,-208,-150,-333,-310,-404,-135,-463,-213,-694,-468,-569,-292,-264,-368,-372,-600,-591,-597,-679,-381,-756,-41,-438,-575,-770,-503,-189,-633,-263,-767,-110,-117,-43,-396,-42,-220,-734,-779,-637,-414,-455,-24,-531,-166,-82,-176,-614,-706,-790,-696,-335,-275,-496,-39,-625,-606,-242,-263,-87,-89,-532,-354,-618,-642,-611,-272,-199,-608,-419,-528,-443,-314,-109,-224,-498,-62,-296,-307,-685,-593,-320,-581,-795,-122,-59,-419,-354,-381,-283,-626,-166,-49,-486,-354,-140,-309,-354,-134,-605,-574,-77,-744,-459,-282,-715,-366,-343,-287,-584,-416,-419,-164,-608,-262,-552,-38,-756,-364,-259,-194,-516,-549,-310,-141,-753,-364,-519,-556,-440,-637,-769,-127,-656,-600,-443,-143,-360,-640,-758,-78,-481,-349,-751,-126,-748,-543,-328,-174,-45,-632,-105,-791,-136,-368,-658,-516,-657,-112,-163,-30,-775,-669,-379,-204,-243,-239,-558,-54,-19,-477,-475,-696,-598,-373,-654,-483,-641,-63,-253,-652,-673,-749,-351,-206,-639,-661,-361,-564,-359,-381,-520,-514,-698,-330,-482,-771,-548,-781,-795,-97,-114,-264,-430,-193,-560,-524,-205,-180,-499,-307,-15,-289,-367,-128,-191,-168,-263,-720,-374,-431,-748,-98,-781,-522,-108,-180,-573,-193,-648,-103,-365,-544,-556,-703,-672,-350,-507,-122,-96,-420,-584,-262,-449,-340,-777,-743,-586,-292,-207,-783,-365,-410,-392,-728,-44,-262,-792,-340,-707,-292,-796,-121,-402,-169,-269,-114,-450,-654,-193,-656,-582,-426,-261,-160,-454,-401,-579,-799,-664,-374,-29,-502,-593,-645,-114,-314,-687,-241,-205,-367,-770,-17,-178,-712,-263,-191,-161,-680,-609,-501,-644,-798,-366,-252,-39,-155,-637,-751,-748,-642,-566,-754,-143,-13,-12,-7,-2,-2,-1,1,2,6,9,18,22,22,23,30,32,32,33,37,38,38,39,42,43,45,45,51,57,58,59,63,66,66,68,68,69,74,77,77,77,85,88,89,91,93,93,96,97,98,101,101,104,108,112,112,113,115,117,117,118,119,125,125,126,126,128,130,130,134,136,136,137,137,139,144,146,147,148,151,151,153,155,157,157,160,165,168,169,169,170,171,172,173,175,180,183,183,185,185,185,188,189,189,190,190,191,192,193,194,196,198,199,199,203,204,205,207,208,209,210,213,213,213,219,223,223,224,225,225,229,230,230,231,234,236,236,240,242,242,242,243,245,245,245,251,256,263,263,274,275,276,279,279,280,286,287,293,296,297,297,298,302,305,305,305,306,306,307,310,311,312,312,319,319,321,323,328,330,333,334,335,335,339,341,343,347,347,351,354,354,354,355,359,364,367,368,370,375,375,380,380,381,382,384,385,388,389,390,394,394,397,397,397,400,400,400,403,407,412,415,417,418,420,421,421,422,426,430,431,435,436,437,439,440,442,444,446,447,448,449,452,452,453,453,454,454,455,459,459,462,463,465,467,467,468,472,476,481,482,484,491,493,500,500,500,504,508,512,514,517,517,520,522,522,524,524,528,529,531,532,532,533,533,534,535,537,537,547,551,552,552,553,553,554,557,560,568,568,570,570,571,572,572,572,573,573,574,577,591,591,592,592,592,594,597,598,599,599,600,603,606,611,615,617,619,619,619,622,622,624,627,628,628,629,630,630,634,638,645,648,649,650,658,658,659,659,661,663,666,666,667,672,673,678,680,682,683,684,685,686,689,692,694,694,695,706,706,710,711,714,714,716,716,718,720,725,727,731,736,736,738,739,741,741,744,748,749,752,752,754,756,756,756,756,757,767,767,767,770,772,776,779,784,785,785,787,790,791,791,792,794,794,795,797,798,800,809,810,810,810,812,814,814,818,819,822,825,831,837,837,837,838,839,839,843,844,845,846,851,853,853,854,859,859,859,863,865,865,867,871,876,876,877,878,879,881,882,883,888,891,892,894,894,900,901,901,904,904};
        System.out.println(Arrays.toString(subSort(array)));
    }

    private static int[] subSort(int[] array) {
        int[] res = new int[]{-1, -1};
        int left = 0;
        int right = 0;
        int length = array.length;
        boolean isOrderly = true;
        // 先升序找到左边最长的有序数组
        for (int i = 0; i < length - 1; i++) {
            if (array[i] > array[i + 1]) {
                isOrderly = false;
                left = i;
                break;
            }
        }
        if (isOrderly) {
            return res;
        }
        // 降序找到右边最长的有序数组
        for (int i = length - 1; i > 0; i--) {
            if (array[i] < array[i - 1] || array[i] < array[left]) {
                right = i;
                break;
            }
        }
        // 理想情况: 中间数组的值不在左右数组的范围之内
        res[0] = left;
        res[1] = right;

        // 在中间段的数组中找到最大和最小值
        int[] midArray = new int[right - left];
        System.arraycopy(array, left, midArray, 0, midArray.length);
        // 数组很大时, 插入排序会很慢, 干脆for循环2次去找最大最小值
        /*for (int i = 0; i < midArray.length; i++) {
            for (int j = i; j > 0 && midArray[j] < midArray[j - 1]; j--) {
                int t = midArray[j];
                midArray[j] = midArray[j - 1];
                midArray[j - 1] = t;
            }
        }*/
        // 不能初始化为0, 因为数组中可能压根不存在这个值！
        int midArrayMin = midArray[0];
        int midArrayMax = midArray[0];
        // 找最大值和最小值
        for (int i = 0; i < midArray.length; i++) {
            if (midArray[i] > midArrayMax) {
                midArrayMax = midArray[i];
            }
            if (midArray[i] < midArrayMin) {
                midArrayMin = midArray[i];
            }
        }
        // 判断最小值是否在左边有序数组值的范围里, 在则找到最近的下标
        for (int i = 0; i < left; i++) {
            if (array[i] > midArrayMin) {
                res[0] = i;
                break;
            }
        }
        // 判断最大值是否在右边有序数组值的范围里, 在则找到最近的下标
        // 注意: 这里需要从右边开始算, 如果从左边开始算找到了符合条件的第一个下标,但是有可能接下来的下标的值和第一个下标值相同
        for (int i = array.length - 1; i >= right ; i--) {
            if (array[i] < midArrayMax) {
                res[1] = i;
                break;
            }
        }
        // 将两个下标存入结果数组返回
        return res;
    }

}
